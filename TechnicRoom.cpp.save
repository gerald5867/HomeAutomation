#include "TechnicRoom.h"
#include <chrono>
#include <thread>
#include <wiringPi.h>
#include "IDevice.h"
#include "ElektrolytPump.h"
#include "Inverter.h"
#include "Logger.h"
#include "TimeoutClock.h"
#include "Ventilation.h"

TechnicRoom::TechnicRoom() {
	wiringPiSetup();
	m_pInv1 = std::make_shared<Inverter>("usb 1-1.4.1");
	m_pInv2 = std::make_shared<Inverter>("/dev/ttyUSB2");
	m_pInv3 = std::make_shared<Inverter>("/dev/ttyUSB3");
	m_pInv4 = std::make_shared<Inverter>("/dev/ttyUSB4");

	m_pVentilation = std::make_unique<Ventilation>(*this);
	m_pPump = std::make_unique<ElektrolytPump>(*this);
}
TechnicRoom::~TechnicRoom() = default;


bool TechnicRoom::AnyInverterLoadsTheBattery() const {
	return
		m_pInv1->IsLoadingBattery() ||
		m_pInv2->IsLoadingBattery() ||
		m_pInv3->IsLoadingBattery() ||
		m_pInv4->IsLoadingBattery();
}


void TechnicRoom::Run() {
	{
		std::vector<std::thread> testThreads;
		for (auto pDevice : IDevice::s_devices) {
			testThreads.emplace_back(std::thread{ [pDevice] {pDevice->TestFunctionality(); } });
		}
		for (auto& testThread : testThreads) {
			testThread.join();
		}
	}
	while (true) {
		auto now = std::chrono::high_resolution_clock::now();
		for (auto pDevice : IDevice::s_devices) {
			if (std::chrono::duration_cast<std::chrono::seconds>(now - pDevice->m_lastUpdate).count() > pDevice->m_updateSeconds) {
				pDevice->Update();
				pDevice->m_lastUpdate = now;
			}
		}
		utils::TimeOutClockSeconds loggerFlushClock{std::chrono::seconds{30}};
		if (loggerFlushClock.IsExpired()){
			utils::Logger::Instance().Flush();
			loggerFlushClock.Reset();
		}
		std::this_thread::sleep_for(std::chrono::seconds(1));
	}
}
